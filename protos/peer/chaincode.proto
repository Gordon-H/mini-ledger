
syntax = "proto3";
package protos;

enum ConfidentialityLevel {
    PUBLIC = 0;
    CONFIDENTIAL = 1;
}


message ChaincodeID {
    //deploy transaction will use the path
    string path = 1;

    //all other requests will use the name (really a hashcode) generated by
    //the deploy transaction
    string name = 2;

    //user friendly version name for the chaincode
    string version = 3;
}

// Carries the chaincode function and its arguments.
// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
// the []byte-based current ChaincodeInput structure.
message ChaincodeInput {
    repeated bytes args  = 1;
    map<string, bytes> decorations = 2;
}

// Carries the chaincode specification. This is the actual metadata required for
// defining a chaincode.
message ChaincodeSpec {

    enum Type {
        UNDEFINED = 0;
        GOLANG = 1;
        NODE = 2;
        CAR = 3;
        JAVA = 4;
    }

    Type type = 1;
    ChaincodeID chaincode_id = 2;
    ChaincodeInput input = 3;
    int32 timeout = 4;
}

// Specify the deployment of a chaincode.
// TODO: Define `codePackage`.
message ChaincodeDeploymentSpec {
    // Prevent removed tag re-use
    reserved 2;
    reserved "effective_date";

    enum ExecutionEnvironment {
        DOCKER = 0;
        SYSTEM = 1;
    }

    ChaincodeSpec chaincode_spec = 1;
    bytes code_package = 3;
    ExecutionEnvironment exec_env=  4;

}

// Carries the chaincode function and its arguments.
message ChaincodeInvocationSpec {
    // Prevent removed tag re-use
    reserved 2;
    reserved "id_generation_alg";

    ChaincodeSpec chaincode_spec = 1;
}

// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
message LifecycleEvent {
    string chaincode_name = 1;
}

// ChaincodeInstallPackage stores the necessary information about a chaincode.
message ChaincodeInstallPackage {
    string type = 1;
    string path = 2;
    bytes code_package = 3;
}
